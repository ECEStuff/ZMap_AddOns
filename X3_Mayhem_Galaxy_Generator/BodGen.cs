using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace X3_Mayhem_Galaxy_Generator
{
    class BodGen
    {
        private static int P = 2;

        /// <summary>
        /// Mirrored/Ported from the original X3 script written by Litcube which created the \objects\cut\00749.bod file based on the loaded galaxy.
        /// Ref:  https://forum.egosoft.com/viewtopic.php?f=94&t=261078
        /// His process was to create a custom map, and then run X3 with it and launch his custom script, which would then create the bod file..  and then he would
        /// simply use that bod file from there as a fixed resource, assuming the map never changed.  Here, we have a new map being generated by this utility
        /// and need a bod file to be generated with it each time.  My understanding is that the .bod file allows X3 to render the LINES between the gates when
        /// you are viewing the galaxy in X3.  The galaxy still has the gates and functions fine but without the .bod file you never see the actual interconnection
        /// lines in the galaxy view in X3.  This is an odd egosoft design but what da hey.
        /// 
        /// Unfortunately, I've never been able to find any X3 reference to what most of these fields actually mean, other than they are 3DS Max related and you might understand them better
        /// if you knew more about 3DS Max .bod structures.  The values and structure here are simply ported from Litcube's script, so he was smart enough to figure it out once, long long ago, in a place far far..
        /// 
        /// 
        /// 3D Scene Information file.
        /// P 3; B 01010201; N 01010201;
        /// { 0x2002;  -32933; 34776; 0;  0.000000; 0.702794; 0.705675; 0.090018;  -1;  -1; } // 0
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="galaxy"></param>
    public static string Generate_00749()
        {
            StringBuilder sb = new StringBuilder();
            string mainsectorstring;
            int baseX = -36433;     // Asthetic only for lines... spacing and length I think.  Use anywhere between -26433 and -36433
            int baseY = 34776;      // same.  use 24776-34776
            int SpacingX = 10000;   // Controls spacing of the Sector squares.
            int SpacingY = 10000;
            int maxx = X3Galaxy.Instance.Sectors.Max(item => item.x) + 1;        // 15  (0-14)
            int maxy = X3Galaxy.Instance.Sectors.Max(item => item.y) + 1;        // 17

            // Required static header.
            sb.AppendLine("VER: 3;");
            sb.AppendLine("P 0; B -1; N Camera01; c");
            sb.AppendLine("  { 0x0808;  0; 0; -19818;  0; 0; 32;  0.000000;  1.570796; -1;  -1; } // 0");

            // Apparently, this file output is only depending on the galaxy's Width, Height, along with whether a particular 2D index (system) exists within that space.
            // Makes sense since it's only being used for interconnect lines on a map.
            // It's possible the file might be allowed to be ordered in sector order as they appear in the galaxy file, but the script example orders them by x,y index so we will as well.
            for (int x = 0; x < maxx; x++)
            {
                for (int y = 0; y < maxy; y++)
                {
                    // If sector with this index exists.
                    if (!X3Galaxy.Instance.Sectors.Exists(item => item.x == x && item.y == y)) continue;
                    X3Sector sector = X3Galaxy.Instance.Sectors.Find(item => item.x == x && item.y == y);

                    mainsectorstring = SecString(x + 1, y + 1);
                    sb.AppendLine($"P {P}; B {mainsectorstring}; N {mainsectorstring};");      // "P 2; B 0101; N 0101;"

                    int mainspacex = baseX + (x * SpacingX);
                    int mainspacey = baseY - (y * SpacingY);
                    sb.AppendLine($"  {{ 0x2002;  {mainspacex}; {mainspacey}; 0;  0.000000; 0.000000; 0.000000; 0.000000;  -1;  -1; }} // 0");    // { 0x2002;  -26433; 24776; 0;  0.000000; 0.000000; 0.000000; 0.000000;  -1;  -1; } // 0
                    P++;

                    // Here, I would have a list of 1-4 gates and we create output for each.
                    // Left Line (west gate, gid=2
                    // < o t = "18" s = "1" x = "-1162684" y = "-47397" z = "-18294466" gid = "1" gx = "0" gy = "1" gtid = "0" a = "32768" b = "0" g = "0" />
                    foreach (X3Gate gate in sector.Gates)
                    {
                        // These offsets shift the gate line slightly.. allow the person some indication that it's more than a 1-system jump in total distance.  Unfortunately
                        // the game doesn't appear to have any capability to render gate lines longer than 1 gate, so this is wha we do if the jump is long.
                        int xoffset = (Math.Abs(sector.y - gate.gy) > 1) ? 500 : 0;
                        int yoffset = (Math.Abs(sector.x - gate.gx) > 1) ? 500 : 0;

                        // This offsets the vertical line subtly to the right indicating it means it's a longer than normal gate.  I wish there were more options here.
                        CreateGateLine(sb, gate.s, gate.gx, gate.gy, mainspacex + xoffset, mainspacey + yoffset, mainsectorstring);
                        P++;
                    }
                }
            }

            return sb.ToString();
        }

        private static void CreateGateLine(StringBuilder sb, int gatedirection, int destX, int destY, int spacex, int spacey, string mainsectorstring)
        {
            string mss = mainsectorstring + SecString(destX + 1, destY + 1);
            sb.AppendLine($"P {P}; B {mss}; N {mss};");

            // NOTE: Mayhem 3's galaxy generator would add an additional ")" at the end of each of these, right after the trailing 0.  I think it was an error, but ignored by the system.  

            // { 0x2002;  x; y; z;  k; 0.702794; 0.705675; 0.090018;  -1;  -1; } // 0
            // x,y,z = 3d display positions of the Sector boxes in the ingame sector map.
            // k = Amoun of Rotation.  0 = 0deg, 0.25 = 90deg, 0.5 = 180deg, 0.75 = 270deg             
            // value is rotation amount from a starting direction of RIGHT (90 degrees to me).  Sign of roation value (1, -1) represents the direction of rotation.
            // 2 = Pitch
            // 3 = Yaw
            // 4 = Roll

            // spacex is the horizontal offset of the line.  for a vertical line, if you add 2000 to it, you shift it's position to the right substantially.
            // spacey "   vertical.
            // The third "0" is the Z-Depth of the line.  Always set to 0.

            switch (gatedirection)
            {
                case 2:     // west     left line.
                    spacex -= 3500;
                    //sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.498793; 0.001430; 0.999658; 0.022553;  -1;  -1; }} // 0");
                    sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.500000; 0.000000; 1.000000;  0.000000;  -1;  -1; }} // 0"); // L
                    break;
                case 3:     // east     right line.
                    spacex += 3500;
                    //sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.000000; 0.702794; 0.705675; 0.090018;  -1;  -1; }} // 0");
                    sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.000000; 0.000000; 1.000000;  0.000000;  -1;  -1; }} // 0"); // R
                    break;
                case 0:     // north
                    spacey += 3500;
                    //sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.471900; 0.702794; 0.705675; 0.090018;  -1;  -1; }} // 0");
                    sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.750000; 0.000000; 0.000000; -1.000000;  -1;  -1; }} // 0"); // U
                    break;
                case 1:     // south
                    spacey -= 3500;
                    //sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.471900; -0.702794; 0.705675; -0.090018;  -1;  -1; }} // 0");
                    sb.AppendLine($"  {{ 0x2002;  {spacex}; {spacey}; 0;  0.250000; 0.000000; 0.000000; -1.000000;  -1;  -1; }} // 0"); // D
                    break;
            }
        }


        private static string SecString(int subX, int subY)
        {
            return LeadZero(subX) + LeadZero(subY);
        }

        private static string LeadZero(int anum)
        {
            if (anum < 10)
            {
                return "0" + anum;
            }
            else return anum.ToString();
        }
    }
}
